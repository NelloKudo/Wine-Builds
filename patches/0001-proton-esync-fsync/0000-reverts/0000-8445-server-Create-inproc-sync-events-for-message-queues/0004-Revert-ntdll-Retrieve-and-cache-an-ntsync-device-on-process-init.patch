--- b/configure
+++ a/configure
@@ -9998,12 +9998,6 @@
 then :
   printf "%s\n" "#define HAVE_LINUX_MAJOR_H 1" >>confdefs.h
 
-fi
-ac_fn_c_check_header_compile "$LINENO" "linux/ntsync.h" "ac_cv_header_linux_ntsync_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_ntsync_h" = xyes
-then :
-  printf "%s\n" "#define HAVE_LINUX_NTSYNC_H 1" >>confdefs.h
-
 fi
 ac_fn_c_check_header_compile "$LINENO" "linux/param.h" "ac_cv_header_linux_param_h" "$ac_includes_default"
 if test "x$ac_cv_header_linux_param_h" = xyes
--- b/configure.ac
+++ a/configure.ac
@@ -682,7 +682,6 @@
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
-	linux/ntsync.h \
 	linux/param.h \
 	linux/serial.h \
 	linux/types.h \
--- b/dlls/ntdll/unix/server.c
+++ a/dlls/ntdll/unix/server.c
@@ -961,7 +961,7 @@
  *
  * Receive a file descriptor passed from the server.
  */
+static int receive_fd( obj_handle_t *handle )
-int wine_server_receive_fd( obj_handle_t *handle )
 {
     struct iovec vec;
     struct msghdr msghdr;
@@ -1156,7 +1156,7 @@
                 if (type) *type = reply->type;
                 if (options) *options = reply->options;
                 access = reply->access;
+                if ((fd = receive_fd( &fd_handle )) != -1)
-                if ((fd = wine_server_receive_fd( &fd_handle )) != -1)
                 {
                     assert( wine_server_ptr_handle(fd_handle) == handle );
                     *needs_close = (!reply->cacheable ||
@@ -1570,7 +1570,6 @@
 {
     const char *arch = getenv( "WINEARCH" );
     const char *env_socket = getenv( "WINESERVERSOCKET" );
-    struct ntdll_thread_data *data = ntdll_get_thread_data();
     obj_handle_t version;
     unsigned int i;
     int ret, reply_pipe;
@@ -1610,7 +1609,7 @@
     pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
 
     /* receive the first thread request fd on the main socket */
+    ntdll_get_thread_data()->request_fd = receive_fd( &version );
-    data->request_fd = wine_server_receive_fd( &version );
 
 #ifdef SO_PASSCRED
     /* now that we hopefully received the server_pid, disable SO_PASSCRED */
@@ -1645,24 +1644,16 @@
         req->unix_pid    = getpid();
         req->unix_tid    = get_unix_tid();
         req->reply_fd    = reply_pipe;
+        req->wait_fd     = ntdll_get_thread_data()->wait_fd[1];
-        req->wait_fd     = data->wait_fd[1];
         req->debug_level = (TRACE_ON(server) != 0);
         wine_server_set_reply( req, supported_machines, sizeof(supported_machines) );
+        ret = wine_server_call( req );
+        pid               = reply->pid;
+        tid               = reply->tid;
+        peb->SessionId    = reply->session_id;
+        info_size         = reply->info_size;
+        server_start_time = reply->server_start;
+        supported_machines_count = wine_server_reply_size( reply ) / sizeof(*supported_machines);
-        if (!(ret = wine_server_call( req )))
-        {
-            obj_handle_t handle;
-            pid               = reply->pid;
-            tid               = reply->tid;
-            peb->SessionId    = reply->session_id;
-            info_size         = reply->info_size;
-            server_start_time = reply->server_start;
-            supported_machines_count = wine_server_reply_size( reply ) / sizeof(*supported_machines);
-            if (reply->inproc_device)
-            {
-                inproc_device_fd = wine_server_receive_fd( &handle );
-                assert( handle == reply->inproc_device );
-            }
-        }
     }
     SERVER_END_REQ;
     close( reply_pipe );
--- b/dlls/ntdll/unix/sync.c
+++ a/dlls/ntdll/unix/sync.c
@@ -57,9 +57,6 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
-#ifdef HAVE_LINUX_NTSYNC_H
-# include <linux/ntsync.h>
-#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -73,7 +70,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
 HANDLE keyed_event = 0;
-int inproc_device_fd = -1;
 
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
 {
@@ -309,63 +305,53 @@
 
 static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                              BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
 static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
                                         BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
     return STATUS_NOT_IMPLEMENTED;
 }
 
--- b/dlls/ntdll/unix/unix_private.h
+++ a/dlls/ntdll/unix/unix_private.h
@@ -197,7 +197,6 @@
 extern USHORT supported_machines[8];
 extern BOOL process_exiting;
 extern HANDLE keyed_event;
-extern int inproc_device_fd;
 extern timeout_t server_start_time;
 extern sigset_t server_block_set;
 extern struct _KUSER_SHARED_DATA *user_shared_data;
@@ -234,7 +233,6 @@
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options );
 extern void wine_server_send_fd( int fd );
-extern int wine_server_receive_fd( obj_handle_t *handle );
 extern void process_exit_wrapper( int status ) DECLSPEC_NORETURN;
 extern size_t server_init_process(void);
 extern void server_init_process_done(void);
--- b/include/config.h.in
+++ a/include/config.h.in
@@ -198,9 +198,6 @@
 /* Define to 1 if you have the <linux/major.h> header file. */
 #undef HAVE_LINUX_MAJOR_H
 
-/* Define to 1 if you have the <linux/ntsync.h> header file. */
-#undef HAVE_LINUX_NTSYNC_H
-
 /* Define to 1 if you have the <linux/param.h> header file. */
 #undef HAVE_LINUX_PARAM_H
 
--- b/include/wine/server_protocol.h
+++ a/include/wine/server_protocol.h
@@ -1148,10 +1148,8 @@
     thread_id_t  tid;
     timeout_t    server_start;
     unsigned int session_id;
-    obj_handle_t inproc_device;
     data_size_t  info_size;
     /* VARARG(machines,ushorts); */
-    char __pad_36[4];
 };
 
 
@@ -6863,6 +6861,6 @@
     struct set_keyboard_repeat_reply set_keyboard_repeat_reply;
 };
 
+#define SERVER_PROTOCOL_VERSION 890
-#define SERVER_PROTOCOL_VERSION 891
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
--- b/server/Makefile.in
+++ a/server/Makefile.in
@@ -16,7 +16,6 @@
 	file.c \
 	handle.c \
 	hook.c \
-	inproc_sync.c \
 	mach.c \
 	mailslot.c \
 	main.c \
--- b/server/inproc_sync.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * In-process synchronization primitives
- *
- * Copyright (C) 2021-2022 Elizabeth Figura for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "config.h"
-
-#include <assert.h>
-#include <stdint.h>
-#include <stdio.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "winternl.h"
-
-#include "file.h"
-#include "handle.h"
-#include "request.h"
-#include "thread.h"
-
-#ifdef HAVE_LINUX_NTSYNC_H
-# include <linux/ntsync.h>
-#endif
-
-#ifdef NTSYNC_IOC_EVENT_READ
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-int get_inproc_device_fd(void)
-{
-    static int fd = -2;
-    if (fd == -2) fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
-    return fd;
-}
-
-#else /* NTSYNC_IOC_EVENT_READ */
-
-int get_inproc_device_fd(void)
-{
-    return -1;
-}
-
-#endif /* NTSYNC_IOC_EVENT_READ */
--- b/server/object.h
+++ a/server/object.h
@@ -240,10 +240,6 @@
 
 extern void abandon_mutexes( struct thread *thread );
 
-/* in-process synchronization functions */
-
-extern int get_inproc_device_fd(void);
-
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
--- b/server/protocol.def
+++ a/server/protocol.def
@@ -1126,7 +1126,6 @@
     thread_id_t  tid;          /* thread id of the new thread */
     timeout_t    server_start; /* server start time */
     unsigned int session_id;   /* process session id */
-    obj_handle_t inproc_device;/* inproc device fd in flight with this handle */
     data_size_t  info_size;    /* total size of startup info */
     VARARG(machines,ushorts);  /* array of supported machines */
 @END
--- b/server/request_handlers.h
+++ a/server/request_handlers.h
@@ -707,9 +707,8 @@
 C_ASSERT( offsetof(struct init_first_thread_reply, tid) == 12 );
 C_ASSERT( offsetof(struct init_first_thread_reply, server_start) == 16 );
 C_ASSERT( offsetof(struct init_first_thread_reply, session_id) == 24 );
+C_ASSERT( offsetof(struct init_first_thread_reply, info_size) == 28 );
+C_ASSERT( sizeof(struct init_first_thread_reply) == 32 );
-C_ASSERT( offsetof(struct init_first_thread_reply, inproc_device) == 28 );
-C_ASSERT( offsetof(struct init_first_thread_reply, info_size) == 32 );
-C_ASSERT( sizeof(struct init_first_thread_reply) == 40 );
 C_ASSERT( offsetof(struct init_thread_request, unix_tid) == 12 );
 C_ASSERT( offsetof(struct init_thread_request, reply_fd) == 16 );
 C_ASSERT( offsetof(struct init_thread_request, wait_fd) == 20 );
--- b/server/request_trace.h
+++ a/server/request_trace.h
@@ -148,7 +148,6 @@
     fprintf( stderr, ", tid=%04x", req->tid );
     dump_timeout( ", server_start=", &req->server_start );
     fprintf( stderr, ", session_id=%08x", req->session_id );
-    fprintf( stderr, ", inproc_device=%04x", req->inproc_device );
     fprintf( stderr, ", info_size=%u", req->info_size );
     dump_varargs_ushorts( ", machines=", cur_size );
 }
--- b/server/thread.c
+++ a/server/thread.c
@@ -1709,7 +1709,6 @@
 DECL_HANDLER(init_first_thread)
 {
     struct process *process = current->process;
-    int fd;
 
     if (!init_thread( current, req->reply_fd, req->wait_fd )) return;
 
@@ -1732,12 +1731,6 @@
     reply->server_start = server_start_time;
     set_reply_data( supported_machines,
                     min( supported_machines_count * sizeof(unsigned short), get_reply_max_size() ));
-
-    if ((fd = get_inproc_device_fd()) >= 0)
-    {
-        reply->inproc_device = get_process_id( process ) | 1;
-        send_client_fd( process, fd, reply->inproc_device );
-    }
 }
 
 /* initialize a new thread */
