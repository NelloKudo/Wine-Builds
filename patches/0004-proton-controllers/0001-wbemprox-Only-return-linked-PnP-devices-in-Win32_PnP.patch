From 0b435105cf5a1cff19586f18dd73342ef69e6197 Mon Sep 17 00:00:00 2001
From: NelloKudo <marshnelloosu@gmail.com>
Date: Mon, 15 Sep 2025 14:56:23 +0200
Subject: [PATCH] wbemprox: Only return linked PnP devices in Win32_PnPEntity

Based on https://github.com/ValveSoftware/wine/commit/299688c29f9a27f4c8850233e1980a2a304b26f0,
rebased to work with the latest changes to wbemprox.

Since fill_pnpentity() no longer relies on SetupDiGetClassDevsW/SetupDiEnumDeviceInfo
to enumerate devices, we now filter device info. directly from registry keys and then check whether
each instance is linked, only reporting these.

Fixes issues with controllers after enabling/disabling Hidraw.
---
 dlls/wbemprox/builtin.c | 139 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 138 insertions(+), 1 deletion(-)

diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index 82af77b8b1c..cd090d6be2f 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -40,6 +40,7 @@
 #include "ntsecapi.h"
 #include "winspool.h"
 #include "ntddstor.h"
+#include "cfgmgr32.h"
 
 #include "wine/debug.h"
 #include "wbemprox_private.h"
@@ -3476,6 +3477,133 @@ static WCHAR *build_pnp_device_id( const WCHAR *class, const WCHAR *product, con
     return ret;
 }
 
+/* see devinst.c */
+static BOOL is_linked(HKEY key)
+{
+    DWORD linked, type, size;
+    HKEY control_key;
+    BOOL ret = FALSE;
+    
+    if (!RegOpenKeyW(key, L"Control", &control_key))
+    {
+        size = sizeof(DWORD);
+        if (!RegQueryValueExW(control_key, L"Linked", NULL, &type, (BYTE *)&linked, &size)
+            && type == REG_DWORD && linked)
+            ret = TRUE;
+        RegCloseKey(control_key);
+    }
+    return ret;
+}
+
+/* iterate over all interfaces supported by this device instance. if any of
+ * them are "linked", return TRUE */
+static BOOL is_device_instance_linked(const WCHAR *deviceInstance)
+{
+    HKEY interfacesKey = NULL;
+    LONG ret;
+    DWORD class_idx = 0, device_idx, keyname_len, devinstance_len, type;
+    HKEY class_key = NULL, device_key = NULL, link_key = NULL;
+    WCHAR class_keyname[40];
+    WCHAR device_keyname[MAX_DEVICE_ID_LEN];
+    WCHAR interface_devinstance[MAX_DEVICE_ID_LEN];
+    BOOL found = FALSE;
+
+    TRACE("deviceInstance %s\n", debugstr_w(deviceInstance));
+
+    if (!deviceInstance)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+    ret = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
+                       L"SYSTEM\\CurrentControlSet\\Control\\DeviceClasses", 
+                       0, KEY_READ, &interfacesKey);
+    if (ret != ERROR_SUCCESS)
+        return FALSE;
+
+    /* Enumerate through all interface classes */
+    while (!found)
+    {
+        keyname_len = ARRAY_SIZE(class_keyname);
+        ret = RegEnumKeyExW(interfacesKey, class_idx++, class_keyname, &keyname_len, 
+                           NULL, NULL, NULL, NULL);
+        if (ret != ERROR_SUCCESS)
+            break;
+
+        ret = RegOpenKeyExW(interfacesKey, class_keyname, 0, KEY_READ, &class_key);
+        if (ret != ERROR_SUCCESS)
+        {
+            WARN("Failed to open class key %s (error %ld)\n", debugstr_w(class_keyname), ret);
+            continue;
+        }
+
+        device_idx = 0;
+        while (!found)
+        {
+            keyname_len = ARRAY_SIZE(device_keyname);
+            ret = RegEnumKeyExW(class_key, device_idx++, device_keyname, &keyname_len,
+                               NULL, NULL, NULL, NULL);
+            if (ret != ERROR_SUCCESS)
+                break;
+
+            ret = RegOpenKeyExW(class_key, device_keyname, 0, KEY_READ, &device_key);
+            if (ret != ERROR_SUCCESS)
+            {
+                WARN("Failed to open device key %s (error %ld)\n", debugstr_w(device_keyname), ret);
+                continue;
+            }
+
+            /* Get the device instance string and check if this matches our target device instance */
+            devinstance_len = sizeof(interface_devinstance);
+            ret = RegQueryValueExW(device_key, L"DeviceInstance", NULL, &type, 
+                                  (BYTE *)interface_devinstance, &devinstance_len);
+            if (ret != ERROR_SUCCESS || type != REG_SZ)
+            {
+                if (ret != ERROR_SUCCESS)
+                    WARN("Failed to query DeviceInstance value (error %ld)\n", ret);
+                RegCloseKey(device_key);
+                device_key = NULL;
+                continue;
+            }
+
+            if (lstrcmpiW(interface_devinstance, deviceInstance) != 0)
+            {
+                RegCloseKey(device_key);
+                device_key = NULL;
+                continue;
+            }
+
+            /* Open the hash subkey to check if it's linked */
+            ret = RegOpenKeyExW(device_key, L"#", 0, KEY_READ, &link_key);
+            if (ret != ERROR_SUCCESS)
+            {
+                WARN("Failed to open hash key for device %s (error %ld)\n", 
+                     debugstr_w(deviceInstance), ret);
+                RegCloseKey(device_key);
+                device_key = NULL;
+                continue;
+            }
+
+            if (is_linked(link_key))
+            {
+                found = TRUE;
+                TRACE("Device instance %s is linked\n", debugstr_w(deviceInstance));
+            }
+
+            RegCloseKey(link_key);
+            link_key = NULL;
+            RegCloseKey(device_key);
+            device_key = NULL;
+        }
+
+        RegCloseKey(class_key);
+        class_key = NULL;
+    }
+
+    RegCloseKey(interfacesKey);
+    return found;
+}
+
 static struct record_pnpentity *get_pnp_entities( UINT *count )
 {
     WCHAR class[MAX_PATH], product[MAX_PATH], instance[MAX_PATH];
@@ -3504,9 +3632,18 @@ static struct record_pnpentity *get_pnp_entities( UINT *count )
                     {
                         if (!RegOpenKeyExW( key_product, instance, 0, KEY_READ, &key_instance ))
                         {
+                            /* Only include devices that have active/linked interfaces */
+                            WCHAR *device_id = build_pnp_device_id( class, product, instance );
+                            if (!device_id || !is_device_instance_linked( device_id ))
+                            {
+                                free( device_id );
+                                RegCloseKey( key_instance );
+                                continue;
+                            }
+                            
                             ret[i].caption = get_reg_value( key_instance, L"DeviceDesc" );
                             ret[i].class_guid = wcslwr( get_reg_value( key_instance, L"ClassGUID" ) );
-                            ret[i].device_id = wcsupr( build_pnp_device_id( class, product, instance ) );
+                            ret[i].device_id = wcsupr( device_id );
                             ret[i].manufacturer = L"The Wine Project";
                             ret[i].name = get_reg_value( key_instance, L"DeviceDesc" );
                             ret[i].service = get_reg_value( key_instance, L"Service" );
-- 
2.51.0

