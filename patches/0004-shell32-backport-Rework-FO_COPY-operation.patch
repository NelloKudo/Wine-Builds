From f5da20c66aee36b6d6d859f106f6e9207ea28ad7 Mon Sep 17 00:00:00 2001
From: NelloKudo <marshnelloosu@gmail.com>
Date: Tue, 1 Jul 2025 21:23:10 +0200
Subject: [PATCH] shell32: backport Rework FO_COPY operation

Backport of Ziqing Hui's original MR (7945) removing tests which aren't really needed in a backport.
Also added a patch from Proton from Paul Gofman to avoid writing past limits in SHELL_FindExecutable (cae7a6cd4aa6b393a022edb6ef00567adcd28832).
---
 dlls/shell32/shlexec.c   |  14 +-
 dlls/shell32/shlfileop.c | 506 +++++++++++++++++++--------------------
 2 files changed, 251 insertions(+), 269 deletions(-)

diff --git a/dlls/shell32/shlexec.c b/dlls/shell32/shlexec.c
index 631601ad21a..8fa19b81bbc 100644
--- a/dlls/shell32/shlexec.c
+++ b/dlls/shell32/shlexec.c
@@ -644,7 +644,7 @@ static UINT SHELL_FindExecutable(LPCWSTR lpPath, LPCWSTR lpFile, LPCWSTR lpVerb,
         }
         if (!found)
         {
-            lstrcpyW(xlpFile, lpFile);
+            wcsncpy_s(xlpFile, ARRAY_SIZE(xlpFile), lpFile, _TRUNCATE);
             if (PathFileExistsDefExtW(xlpFile, 0xbf) || PathFileExistsW(xlpFile))
             {
                 GetFullPathNameW(xlpFile, ARRAY_SIZE(xlpFile), xlpFile, NULL);
@@ -654,7 +654,7 @@ static UINT SHELL_FindExecutable(LPCWSTR lpPath, LPCWSTR lpFile, LPCWSTR lpVerb,
         if (found)
         {
             lpFile = xlpFile;
-            lstrcpyW(lpResult, xlpFile);
+            wcsncpy_s(lpResult, resultLen, xlpFile, _TRUNCATE);
         }
         else
             xlpFile[0] = '\0';
@@ -668,13 +668,13 @@ static UINT SHELL_FindExecutable(LPCWSTR lpPath, LPCWSTR lpFile, LPCWSTR lpVerb,
         }
         else
             search_paths[0] = curdir;
-        lstrcpyW(xlpFile, lpFile);
+        wcsncpy_s(xlpFile, ARRAY_SIZE(xlpFile), lpFile, _TRUNCATE);
         if (PathResolveW(xlpFile, search_paths, PRF_TRYPROGRAMEXTENSIONS | PRF_VERIFYEXISTS) ||
             PathFindOnPathW(xlpFile, search_paths))
         {
             TRACE("PathResolveAW returned non-zero\n");
             lpFile = xlpFile;
-            lstrcpyW(lpResult, xlpFile);
+            wcsncpy_s(lpResult, resultLen, xlpFile, _TRUNCATE);
             /* The file was found in lpPath or one of the directories in the system-wide search path */
         }
         else
@@ -800,16 +800,16 @@ static UINT SHELL_FindExecutable(LPCWSTR lpPath, LPCWSTR lpFile, LPCWSTR lpVerb,
         {
             if (*command)
             {
-                lstrcpyW(lpResult, command);
+                wcsncpy_s(lpResult, resultLen, command, _TRUNCATE);
                 tok = wcschr(lpResult, '^'); /* should be ^.extension? */
                 if (tok != NULL)
                 {
                     tok[0] = '\0';
-                    lstrcatW(lpResult, xlpFile); /* what if no dir in xlpFile? */
+                    wcscat_s(lpResult, resultLen, xlpFile); /* what if no dir in xlpFile? */
                     tok = wcschr(command, '^'); /* see above */
                     if ((tok != NULL) && (lstrlenW(tok)>5))
                     {
-                        lstrcatW(lpResult, &tok[5]);
+                        wcscat_s(lpResult, resultLen, &tok[5]);
                     }
                 }
                 retval = 33; /* FIXME - see above */
diff --git a/dlls/shell32/shlfileop.c b/dlls/shell32/shlfileop.c
index 4fb0642fc5d..f24c7b7df23 100644
--- a/dlls/shell32/shlfileop.c
+++ b/dlls/shell32/shlfileop.c
@@ -54,8 +54,19 @@ WINE_DEFAULT_DEBUG_CHANNEL(shell);
 
 #define FO_MASK         0xF
 
-#define DE_SAMEFILE      0x71
-#define DE_DESTSAMETREE  0x7D
+#define DE_SAMEFILE        0x71
+#define DE_MANYSRC1DEST    0x72
+#define DE_DIFFDIR         0x73
+#define DE_ROOTDIR         0x74
+#define DE_OPCANCELLED     0x75
+#define DE_DESTSUBTREE     0x76
+#define DE_ACCESSDENIEDSRC 0x78
+#define DE_PATHTOODEEP     0x79
+#define DE_MANYDEST        0x7A
+#define DE_INVALIDFILES    0x7C
+#define DE_DESTSAMETREE    0x7D
+#define DE_FLDDESTISFILE   0x7E
+#define DE_FILEDESTISFLD   0x80
 
 static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec);
 static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec);
@@ -910,7 +921,6 @@ typedef struct
     LPWSTR szFilename;
     LPWSTR szFullPath;
     BOOL bFromWildcard;
-    BOOL bFromRelative;
     BOOL bExists;
 } FILE_ENTRY;
 
@@ -924,6 +934,7 @@ typedef struct
     BOOL bAnyDontExist;
 } FILE_LIST;
 
+static DWORD do_copy(FILE_OPERATION *op, const FILE_ENTRY *from, const FILE_ENTRY *to, BOOL append_file_name);
 
 static inline void grow_list(FILE_LIST *list)
 {
@@ -932,28 +943,78 @@ static inline void grow_list(FILE_LIST *list)
     list->num_alloc *= 2;
 }
 
-/* adds a file to the FILE_ENTRY struct
- */
-static void add_file_to_entry(FILE_ENTRY *feFile, LPCWSTR szFile)
+static void file_entry_init(FILE_ENTRY *file_entry,
+        const WCHAR *file_name, DWORD attributes, BOOL from_wildcard)
 {
-    DWORD dwLen = lstrlenW(szFile) + 1;
-    LPCWSTR ptr;
+    size_t file_name_len = wcslen(file_name) + 1;
+    const WCHAR *ptr;
 
-    feFile->szFullPath = malloc(dwLen * sizeof(WCHAR));
-    lstrcpyW(feFile->szFullPath, szFile);
+    file_entry->szFullPath = malloc(file_name_len * sizeof(WCHAR));
+    wcscpy(file_entry->szFullPath, file_name);
 
-    ptr = StrRChrW(szFile, NULL, '\\');
+    ptr = wcsrchr(file_name, '\\');
     if (ptr)
     {
-        dwLen = ptr - szFile + 1;
-        feFile->szDirectory = malloc(dwLen * sizeof(WCHAR));
-        lstrcpynW(feFile->szDirectory, szFile, dwLen);
+        file_name_len = ptr - file_name + 1;
+        file_entry->szDirectory = malloc(file_name_len * sizeof(WCHAR));
+        lstrcpynW(file_entry->szDirectory, file_name, file_name_len);
 
-        dwLen = lstrlenW(feFile->szFullPath) - dwLen + 1;
-        feFile->szFilename = malloc(dwLen * sizeof(WCHAR));
-        lstrcpyW(feFile->szFilename, ptr + 1); /* skip over backslash */
+        file_name_len = wcslen(file_entry->szFullPath) - file_name_len + 1;
+        file_entry->szFilename = malloc(file_name_len * sizeof(WCHAR));
+        lstrcpyW(file_entry->szFilename, ptr + 1); /* Skip over backslash. */
     }
-    feFile->bFromWildcard = FALSE;
+
+    file_entry->attributes = attributes;
+    file_entry->bFromWildcard = from_wildcard;
+    file_entry->bExists = (attributes != INVALID_FILE_ATTRIBUTES);
+}
+
+static void file_entry_destroy(FILE_ENTRY *file_entry)
+{
+    if (!file_entry)
+        return;
+    if (file_entry->szDirectory)
+        free(file_entry->szDirectory);
+    if(file_entry->szFilename)
+        free(file_entry->szFilename);
+    if (file_entry->szFullPath)
+        free(file_entry->szFullPath);
+}
+
+static void file_list_add_entry(FILE_LIST *file_list,
+        const WCHAR *file_name, DWORD attributes, BOOL from_wildcard)
+{
+    FILE_ENTRY *file_entry;
+
+    if (file_list->dwNumFiles >= file_list->num_alloc)
+        grow_list(file_list);
+    file_entry = &file_list->feFiles[file_list->dwNumFiles++];
+
+    file_entry_init(file_entry, file_name, attributes, from_wildcard);
+
+    if (IsAttribDir(attributes))
+        file_list->bAnyDirectories = TRUE;
+    if (from_wildcard)
+        file_list->bAnyFromWildcard = TRUE;
+    if (!file_entry->bExists && !file_entry->bFromWildcard)
+        file_list->bAnyDontExist = TRUE;
+}
+
+static void file_list_destroy(FILE_LIST *flList)
+{
+    DWORD i;
+
+    if (!flList || !flList->feFiles)
+        return;
+
+    for (i = 0; i < flList->dwNumFiles; i++)
+        file_entry_destroy(&flList->feFiles[i]);
+    free(flList->feFiles);
+}
+
+static BOOL has_wildcard(const WCHAR *str)
+{
+    return !!wcspbrk(str, L"*?");
 }
 
 static LPWSTR wildcard_to_file(LPCWSTR szWildCard, LPCWSTR szFileName)
@@ -974,11 +1035,10 @@ static LPWSTR wildcard_to_file(LPCWSTR szWildCard, LPCWSTR szFileName)
     return szFullPath;
 }
 
-static void parse_wildcard_files(FILE_LIST *flList, LPCWSTR szFile, LPDWORD pdwListIndex)
+static void parse_wildcard_files(FILE_LIST *file_list, LPCWSTR szFile)
 {
     WIN32_FIND_DATAW wfd;
     HANDLE hFile = FindFirstFileW(szFile, &wfd);
-    FILE_ENTRY *file;
     LPWSTR szFullPath;
     BOOL res;
 
@@ -987,13 +1047,8 @@ static void parse_wildcard_files(FILE_LIST *flList, LPCWSTR szFile, LPDWORD pdwL
     for (res = TRUE; res; res = FindNextFileW(hFile, &wfd))
     {
         if (IsDotDir(wfd.cFileName)) continue;
-        if (*pdwListIndex >= flList->num_alloc) grow_list( flList );
         szFullPath = wildcard_to_file(szFile, wfd.cFileName);
-        file = &flList->feFiles[(*pdwListIndex)++];
-        add_file_to_entry(file, szFullPath);
-        file->bFromWildcard = TRUE;
-        file->attributes = wfd.dwFileAttributes;
-        if (IsAttribDir(file->attributes)) flList->bAnyDirectories = TRUE;
+        file_list_add_entry(file_list, szFullPath, wfd.dwFileAttributes, TRUE);
         free(szFullPath);
     }
 
@@ -1001,159 +1056,71 @@ static void parse_wildcard_files(FILE_LIST *flList, LPCWSTR szFile, LPDWORD pdwL
 }
 
 /* takes the null-separated file list and fills out the FILE_LIST */
-static HRESULT parse_file_list(FILE_LIST *flList, LPCWSTR szFiles)
+static void parse_file_list(FILE_LIST *flList, LPCWSTR szFiles, BOOL parse_wildcard)
 {
     LPCWSTR ptr = szFiles;
     WCHAR szCurFile[MAX_PATH];
     WCHAR *p;
-    DWORD i = 0;
-
-    if (!szFiles)
-        return ERROR_INVALID_PARAMETER;
 
     flList->bAnyFromWildcard = FALSE;
     flList->bAnyDirectories = FALSE;
     flList->bAnyDontExist = FALSE;
     flList->num_alloc = 32;
     flList->dwNumFiles = 0;
-
-    /* empty list */
-    if (!szFiles[0])
-        return ERROR_ACCESS_DENIED;
-
     flList->feFiles = calloc(flList->num_alloc, sizeof(FILE_ENTRY));
 
     while (*ptr)
     {
-        if (i >= flList->num_alloc) grow_list( flList );
+        BOOL from_wildcard = has_wildcard(ptr);
 
         /* change relative to absolute path */
         if (PathIsRelativeW(ptr))
         {
             GetCurrentDirectoryW(MAX_PATH, szCurFile);
             PathCombineW(szCurFile, szCurFile, ptr);
-            flList->feFiles[i].bFromRelative = TRUE;
         }
         else
         {
             lstrcpyW(szCurFile, ptr);
-            flList->feFiles[i].bFromRelative = FALSE;
         }
 
         for (p = szCurFile; *p; p++) if (*p == '/') *p = '\\';
 
         /* parse wildcard files if they are in the filename */
-        if (StrPBrkW(szCurFile, L"*?"))
-        {
-            parse_wildcard_files(flList, szCurFile, &i);
-            flList->bAnyFromWildcard = TRUE;
-            i--;
-        }
+        if (from_wildcard && parse_wildcard)
+            parse_wildcard_files(flList, szCurFile);
         else
-        {
-            FILE_ENTRY *file = &flList->feFiles[i];
-            add_file_to_entry(file, szCurFile);
-            file->attributes = GetFileAttributesW( file->szFullPath );
-            file->bExists = (file->attributes != INVALID_FILE_ATTRIBUTES);
-            if (!file->bExists) flList->bAnyDontExist = TRUE;
-            if (IsAttribDir(file->attributes)) flList->bAnyDirectories = TRUE;
-        }
+            file_list_add_entry(flList, szCurFile, GetFileAttributesW(szCurFile), from_wildcard);
 
         /* advance to the next string */
         ptr += lstrlenW(ptr) + 1;
-        i++;
     }
-    flList->dwNumFiles = i;
-
-    return S_OK;
 }
 
-/* free the FILE_LIST */
-static void destroy_file_list(FILE_LIST *flList)
+static DWORD parse_target_file_list(const SHFILEOPSTRUCTW *op, DWORD source_file_count, FILE_LIST *out)
 {
-    DWORD i;
+    DWORD i, check_count = 1;
 
-    if (!flList || !flList->feFiles)
-        return;
-
-    for (i = 0; i < flList->dwNumFiles; i++)
-    {
-        free(flList->feFiles[i].szDirectory);
-        free(flList->feFiles[i].szFilename);
-        free(flList->feFiles[i].szFullPath);
-    }
-
-    free(flList->feFiles);
-}
-
-static void copy_dir_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, LPCWSTR szDestPath)
-{
-    WCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
-    SHFILEOPSTRUCTW fileOp;
+    if (op->wFunc == FO_DELETE)
+        return ERROR_SUCCESS;
+    if (!op->pTo)
+        return ERROR_ACCESS_DENIED;
 
-    if (IsDotDir(feFrom->szFilename))
-        return;
+    parse_file_list(out, op->pTo, FALSE);
 
-    if (PathFileExistsW(szDestPath))
-        PathCombineW(szTo, szDestPath, feFrom->szFilename);
-    else
-        lstrcpyW(szTo, szDestPath);
+    if (op->fFlags & FOF_MULTIDESTFILES)
+        check_count = min(source_file_count, out->dwNumFiles);
 
-    if (!(op->req->fFlags & FOF_NOCONFIRMATION) && PathFileExistsW(szTo)) {
-        if (!SHELL_ConfirmDialogW(op->req->hwnd, ASK_OVERWRITE_FOLDER, feFrom->szFilename, op))
+    for (i = 0; i < check_count; ++i)
+    {
+        if (out->feFiles[i].bFromWildcard)
         {
-            /* Vista returns an ERROR_CANCELLED even if user pressed "No" */
-            if (!op->bManyItems)
-                op->bCancelled = TRUE;
-            return;
+            file_list_destroy(out);
+            return ERROR_INVALID_NAME;
         }
     }
 
-    szTo[lstrlenW(szTo) + 1] = '\0';
-    SHNotifyCreateDirectoryW(szTo, NULL);
-
-    PathCombineW(szFrom, feFrom->szFullPath, L"*.*");
-    szFrom[lstrlenW(szFrom) + 1] = '\0';
-
-    fileOp = *op->req;
-    fileOp.pFrom = szFrom;
-    fileOp.pTo = szTo;
-    fileOp.fFlags &= ~FOF_MULTIDESTFILES; /* we know we're copying to one dir */
-
-    /* Don't ask the user about overwriting files when he accepted to overwrite the
-       folder. FIXME: this is not exactly what Windows does - e.g. there would be
-       an additional confirmation for a nested folder */
-    fileOp.fFlags |= FOF_NOCONFIRMATION;  
-
-    SHFileOperationW(&fileOp);
-}
-
-static BOOL copy_file_to_file(FILE_OPERATION *op, const WCHAR *szFrom, const WCHAR *szTo)
-{
-    if (!(op->req->fFlags & FOF_NOCONFIRMATION) && PathFileExistsW(szTo))
-    {
-        if (!SHELL_ConfirmDialogW(op->req->hwnd, ASK_OVERWRITE_FILE, PathFindFileNameW(szTo), op))
-            return FALSE;
-    }
-
-    return SHNotifyCopyFileW(szFrom, szTo, FALSE) == 0;
-}
-
-/* copy a file or directory to another directory */
-static void copy_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
-{
-    if (!PathFileExistsW(feTo->szFullPath))
-        SHNotifyCreateDirectoryW(feTo->szFullPath, NULL);
-
-    if (IsAttribFile(feFrom->attributes))
-    {
-        WCHAR szDestPath[MAX_PATH];
-
-        PathCombineW(szDestPath, feTo->szFullPath, feFrom->szFilename);
-        copy_file_to_file(op, feFrom->szFullPath, szDestPath);
-    }
-    else if (!(op->req->fFlags & FOF_FILESONLY && feFrom->bFromWildcard))
-        copy_dir_to_dir(op, feFrom, feTo->szFullPath);
+    return ERROR_SUCCESS;
 }
 
 static void create_dest_dirs(LPCWSTR szDestDir)
@@ -1175,130 +1142,138 @@ static void create_dest_dirs(LPCWSTR szDestDir)
         SHNotifyCreateDirectoryW(szDestDir, NULL);
 }
 
-/* the FO_COPY operation */
-static int copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *flTo)
+static DWORD copy_wildcard(FILE_OPERATION *op, const FILE_ENTRY *from, const FILE_ENTRY *to)
 {
-    DWORD i;
-    const FILE_ENTRY *entryToCopy;
-    const FILE_ENTRY *fileDest = &flTo->feFiles[0];
+    WCHAR buffer[MAX_PATH + 1] = {};
+    FILE_LIST from_files;
+    DWORD i, ret;
 
-    if (flFrom->bAnyDontExist)
-        return ERROR_SHELL_INTERNAL_FILE_NOT_FOUND;
+    wcscpy(buffer, from->szFullPath);
+    parse_file_list(&from_files, buffer, TRUE);
 
-    if (flTo->dwNumFiles == 0)
+    for (i = 0; i < from_files.dwNumFiles; ++i)
     {
-        /* If the destination is empty, SHFileOperation should use the current directory */
-        WCHAR curdir[MAX_PATH+1];
+        if ((ret = do_copy(op, &from_files.feFiles[i], to, TRUE)) != ERROR_SUCCESS)
+            break;
+    }
 
-        GetCurrentDirectoryW(MAX_PATH, curdir);
-        curdir[lstrlenW(curdir)+1] = 0;
+    file_list_destroy(&from_files);
+    return ret;
+}
 
-        destroy_file_list(flTo);
-        ZeroMemory(flTo, sizeof(FILE_LIST));
-        parse_file_list(flTo, curdir);
-        fileDest = &flTo->feFiles[0];
-    }
+static DWORD copy_dir(FILE_OPERATION *op, const WCHAR *dir, const WCHAR *target)
+{
+    WCHAR buffer[MAX_PATH];
+    FILE_ENTRY from_dir, to_dir;
+    DWORD ret;
 
-    if (op->req->fFlags & FOF_MULTIDESTFILES && flTo->dwNumFiles > 1)
-    {
-        if (flFrom->bAnyFromWildcard)
-            return ERROR_CANCELLED;
+    if (op->req->fFlags & FOF_FILESONLY)
+        return ERROR_SUCCESS;
 
-        if (flFrom->dwNumFiles != flTo->dwNumFiles)
-        {
-            if (flFrom->dwNumFiles != 1 && !IsAttribDir(fileDest->attributes))
-                return ERROR_CANCELLED;
+    PathCombineW(buffer, dir, L"*.*");
+    file_entry_init(&from_dir, buffer, INVALID_FILE_ATTRIBUTES, TRUE);
+    file_entry_init(&to_dir, target, GetFileAttributesW(target), FALSE);
 
-            /* Free all but the first entry. */
-            for (i = 1; i < flTo->dwNumFiles; i++)
-            {
-                free(flTo->feFiles[i].szDirectory);
-                free(flTo->feFiles[i].szFilename);
-                free(flTo->feFiles[i].szFullPath);
-            }
+    ret = do_copy(op, &from_dir, &to_dir, TRUE);
 
-            flTo->dwNumFiles = 1;
-        }
-        else if (IsAttribDir(fileDest->attributes))
-        {
-            for (i = 1; i < flTo->dwNumFiles; i++)
-                if (!IsAttribDir(flTo->feFiles[i].attributes) ||
-                    !IsAttribDir(flFrom->feFiles[i].attributes))
-                {
-                    return ERROR_CANCELLED;
-                }
-        }
-    }
-    else if (flFrom->dwNumFiles != 1)
-    {
-        if (flTo->dwNumFiles != 1 && !IsAttribDir(fileDest->attributes))
-            return ERROR_CANCELLED;
+    file_entry_destroy(&to_dir);
+    file_entry_destroy(&from_dir);
+    return ret;
+}
 
-        if (PathFileExistsW(fileDest->szFullPath) &&
-            IsAttribFile(fileDest->attributes))
-        {
-            return ERROR_CANCELLED;
-        }
+static DWORD do_copy(FILE_OPERATION *op, const FILE_ENTRY *from, const FILE_ENTRY *to, BOOL append_file_name)
+{
+    WCHAR target[MAX_PATH], target_dir[MAX_PATH];
 
-        if (flTo->dwNumFiles == 1 && fileDest->bFromRelative &&
-            !PathFileExistsW(fileDest->szFullPath))
-        {
-            return ERROR_CANCELLED;
-        }
+    TRACE("Copying %s to %s, flags %#x, append_file_name %d.\n",
+            debugstr_w(from->szFullPath), debugstr_w(to->szFullPath), op->req->fFlags, append_file_name);
+
+    /* Determine target path. */
+    wcscpy(target_dir, to->szDirectory);
+    wcscpy(target, to->szFullPath);
+    if (append_file_name)
+    {
+        PathAppendW(target_dir, to->szFilename);
+        PathAppendW(target, from->szFilename);
     }
 
-    for (i = 0; i < flFrom->dwNumFiles; i++)
+    /* Fail if target is illegal. */
+    if (PathFileExistsW(target))
     {
-        entryToCopy = &flFrom->feFiles[i];
+        BOOL target_is_dir = !!PathIsDirectoryW(target);
+        if (target_is_dir != IsAttribDir(from->attributes))
+            return target_is_dir ? DE_FILEDESTISFLD : DE_FLDDESTISFILE;
+        if (wcscmp(target, from->szFullPath) == 0)
+            return target_is_dir ? DE_DESTSAMETREE : DE_SAMEFILE;
+        if (!(op->req->fFlags & FOF_NOCONFIRMATION)
+                && !SHELL_ConfirmDialogW(op->req->hwnd, target_is_dir ? ASK_OVERWRITE_FOLDER : ASK_OVERWRITE_FILE,
+                        PathFindFileNameW(target), op))
+            return DE_OPCANCELLED;
+    }
+    if (PathIsPrefixW(from->szFullPath, to->szFullPath))
+        return DE_DESTSUBTREE;
 
-        if ((op->req->fFlags & FOF_MULTIDESTFILES) &&
-            flTo->dwNumFiles > 1)
-        {
-            fileDest = &flTo->feFiles[i];
-        }
+    /* Create target dir. */
+    if (!PathFileExistsW(target_dir))
+        SHCreateDirectoryExW(NULL, target_dir, NULL);
 
-        if (IsAttribDir(entryToCopy->attributes) &&
-            !lstrcmpiW(entryToCopy->szFullPath, fileDest->szDirectory))
-        {
-            return ERROR_SUCCESS;
-        }
+    /* Source contains wildcard. */
+    if (has_wildcard(from->szFullPath))
+        return copy_wildcard(op, from, to);
 
-        create_dest_dirs(fileDest->szDirectory);
+    /* Source is a dir. */
+    if (IsAttribDir(from->attributes))
+        return copy_dir(op, from->szFullPath, target);
 
-        if (!lstrcmpiW(entryToCopy->szFullPath, fileDest->szFullPath))
-        {
-            if (IsAttribFile(entryToCopy->attributes))
-                return ERROR_NO_MORE_SEARCH_HANDLES;
-            else
-                return ERROR_SUCCESS;
-        }
+    /* Source is a single file. */
+    return SHNotifyCopyFileW(from->szFullPath, target, FALSE);
+}
 
-        if ((flFrom->dwNumFiles > 1 && flTo->dwNumFiles == 1) ||
-            IsAttribDir(fileDest->attributes))
-        {
-            copy_to_dir(op, entryToCopy, fileDest);
-        }
-        else if (IsAttribDir(entryToCopy->attributes))
+/* The FO_COPY operation. */
+static DWORD copy_files(FILE_OPERATION *op, const FILE_LIST *from, FILE_LIST *to)
+{
+    BOOL append_file_name, multi_dst, multi_src;
+    FILE_ENTRY current = {}, *target;
+    DWORD ret = ERROR_SUCCESS, i;
+
+    if (from->bAnyDontExist)
+        return ERROR_FILE_NOT_FOUND;
+
+    multi_src = from->dwNumFiles > 1;
+    multi_dst = op->req->fFlags & FOF_MULTIDESTFILES;
+
+    /* Do copy operation for each source file. */
+    for (i = 0; i < from->dwNumFiles; ++i)
+    {
+        DWORD target_index = multi_dst ? i : 0;
+
+        if (target_index < to->dwNumFiles && to->feFiles[target_index].szFullPath[0] != '\0')
         {
-            copy_dir_to_dir(op, entryToCopy, fileDest->szFullPath);
+            target = &to->feFiles[target_index];
         }
         else
         {
-            if (!copy_file_to_file(op, entryToCopy->szFullPath, fileDest->szFullPath))
+            /* Empty target, use current directory. */
+            if (!current.szFullPath)
             {
-                op->req->fAnyOperationsAborted = TRUE;
-                return ERROR_CANCELLED;
+                WCHAR buffer[MAX_PATH];
+                GetCurrentDirectoryW(MAX_PATH, buffer);
+                file_entry_init(&current, buffer, GetFileAttributesW(buffer), FALSE);
             }
+            target = &current;
         }
 
-        /* Vista return code. XP would return e.g. ERROR_FILE_NOT_FOUND, ERROR_ALREADY_EXISTS */
-        if (op->bCancelled)
-            return ERROR_CANCELLED;
+        append_file_name = from->bAnyFromWildcard
+                || ((multi_src || IsAttribDir(target->attributes))
+                && (!multi_dst || from->dwNumFiles != to->dwNumFiles));
+
+        /* Do copy operation. */
+        if ((ret = do_copy(op, &from->feFiles[i], target, append_file_name)) != ERROR_SUCCESS)
+            break;
     }
 
-    /* Vista return code. On XP if the used pressed "No" for the last item,
-     * ERROR_ARENA_TRASHED would be returned */
-    return ERROR_SUCCESS;
+    file_entry_destroy(&current);
+    return ret;
 }
 
 static BOOL confirm_delete_list(HWND hWnd, DWORD fFlags, BOOL fTrash, const FILE_LIST *flFrom)
@@ -1514,30 +1489,31 @@ static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const
     return ERROR_SUCCESS;
 }
 
-/* the FO_RENAME files */
-static int rename_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const FILE_LIST *flTo)
+/* The FO_RENAME operation of SHFileOperation. */
+static DWORD rename_files(SHFILEOPSTRUCTW *op, const FILE_LIST *from, const FILE_LIST *to)
 {
-    const FILE_ENTRY *feFrom;
-    const FILE_ENTRY *feTo;
+    const FILE_ENTRY *entry_from, *entry_to;
 
-    if (flFrom->dwNumFiles != 1)
-        return ERROR_GEN_FAILURE;
+    if (from->dwNumFiles != 1)
+        return DE_MANYSRC1DEST;
 
-    if (flTo->dwNumFiles != 1)
-        return ERROR_CANCELLED;
+    entry_from = &from->feFiles[0];
+    if (entry_from->bFromWildcard)
+        return DE_MANYSRC1DEST;
+    if (!entry_from->bExists)
+        return ERROR_FILE_NOT_FOUND;
 
-    feFrom = &flFrom->feFiles[0];
-    feTo= &flTo->feFiles[0];
+    if (!to->dwNumFiles)
+        return DE_DIFFDIR;
+    entry_to = &to->feFiles[0];
 
-    /* fail if destination doesn't exist */
-    if (!feFrom->bExists)
-        return ERROR_SHELL_INTERNAL_FILE_NOT_FOUND;
+    if (wcscmp(entry_from->szDirectory, entry_to->szDirectory) != 0)
+        return DE_DIFFDIR;
 
-    /* fail if destination already exists */
-    if (feTo->bExists)
-        return ERROR_ALREADY_EXISTS;
+    if (entry_to->bExists && IsAttribDir(entry_from->attributes) != IsAttribDir(entry_to->attributes))
+        return IsAttribDir(entry_to->attributes) ? DE_FILEDESTISFLD : DE_FLDDESTISFILE;
 
-    return SHNotifyMoveFileW(feFrom->szFullPath, feTo->szFullPath);
+    return SHNotifyMoveFileW(entry_from->szFullPath, entry_to->szFullPath);
 }
 
 /* alert the user if an unsupported flag is used */
@@ -1558,29 +1534,38 @@ static void check_flags(FILEOP_FLAGS fFlags)
  */
 int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
 {
+    BOOL parse_wildcard = (lpFileOp->wFunc != FO_RENAME && lpFileOp->wFunc != FO_COPY);
     FILE_OPERATION op;
     FILE_LIST flFrom, flTo;
     int ret = 0;
 
-    if (!lpFileOp)
+    if (!lpFileOp || !lpFileOp->pFrom)
         return ERROR_INVALID_PARAMETER;
 
     check_flags(lpFileOp->fFlags);
 
-    ZeroMemory(&flFrom, sizeof(FILE_LIST));
-    ZeroMemory(&flTo, sizeof(FILE_LIST));
-
-    if ((ret = parse_file_list(&flFrom, lpFileOp->pFrom)))
-        return ret;
-
-    if (lpFileOp->wFunc != FO_DELETE)
-        parse_file_list(&flTo, lpFileOp->pTo);
-
     ZeroMemory(&op, sizeof(op));
     op.req = lpFileOp;
-    op.bManyItems = (flFrom.dwNumFiles > 1);
     lpFileOp->fAnyOperationsAborted = FALSE;
 
+    if (lpFileOp->wFunc != FO_MOVE
+            && lpFileOp->wFunc != FO_COPY
+            && lpFileOp->wFunc != FO_DELETE
+            && lpFileOp->wFunc != FO_RENAME)
+        return ERROR_INVALID_PARAMETER;
+
+    /* Parse source file list. */
+    memset(&flFrom, 0, sizeof(flFrom));
+    parse_file_list(&flFrom, lpFileOp->pFrom, parse_wildcard);
+    op.bManyItems = (flFrom.dwNumFiles > 1);
+
+    memset(&flTo, 0, sizeof(flTo));
+    if ((ret = parse_target_file_list(lpFileOp, flFrom.dwNumFiles, &flTo)) != ERROR_SUCCESS)
+    {
+        file_list_destroy(&flFrom);
+        return ret;
+    }
+
     switch (lpFileOp->wFunc)
     {
         case FO_COPY:
@@ -1596,14 +1581,11 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
             ret = rename_files(lpFileOp, &flFrom, &flTo);
             break;
         default:
-            ret = ERROR_INVALID_PARAMETER;
-            break;
+            assert(0); /* Should never be here. */
     }
 
-    destroy_file_list(&flFrom);
-
-    if (lpFileOp->wFunc != FO_DELETE)
-        destroy_file_list(&flTo);
+    file_list_destroy(&flFrom);
+    file_list_destroy(&flTo);
 
     if (ret == ERROR_CANCELLED)
         lpFileOp->fAnyOperationsAborted = TRUE;
-- 
2.50.0

